;buildInfoPackage: chisel3, version: 3.4.2, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit NetStack : 
  extmodule FpgaPll : 
    input clk_in : Clock
    input reset : Reset
    output clk_100 : Clock
    output clk_125 : Clock
    output clk_200 : Clock
    output clk_250 : Clock
    output locked : UInt<1>
    
    defname = FpgaPll
    
    
  extmodule FpgaPhasePll : 
    input clk_in : Clock
    input reset : Reset
    output clk_p45 : Clock
    output clk_p90 : Clock
    output clk_p180 : Clock
    output clk_p225 : Clock
    output clk_p270 : Clock
    
    defname = FpgaPhasePll
    
    
  extmodule FpgaFifo : 
    input rst : Reset
    input wr_clk : Clock
    input rd_clk : Clock
    input din : UInt<4>
    input wr_en : UInt<1>
    input rd_en : UInt<1>
    output dout : UInt<4>
    output full : UInt<1>
    output empty : UInt<1>
    
    defname = FpgaFifo
    
    
  extmodule FpgaFifo_1 : 
    input rst : Reset
    input wr_clk : Clock
    input rd_clk : Clock
    input din : UInt<4>
    input wr_en : UInt<1>
    input rd_en : UInt<1>
    output dout : UInt<4>
    output full : UInt<1>
    output empty : UInt<1>
    
    defname = FpgaFifo
    
    
  module RgmiiTransfer : 
    input clock : Clock
    input reset : Reset
    output io : {rgmii : {txClock : UInt<1>, txData : UInt<4>, txCtrl : UInt<1>, flip rxClock : UInt<1>, flip rxData : UInt<4>, flip rxCtrl : UInt<1>, ereset : UInt<1>}, rx : {valid : UInt<1>, bits : UInt<8>}, flip tx : {valid : UInt<1>, bits : UInt<8>}, debugPort : {rgmiiRxClock : UInt<1>, rgmiiRxCtrl : UInt<1>, rgmiiRxData : UInt<4>, rxValid : UInt<1>, rxData : UInt<8>, riseFifo : UInt<4>, fallFifo : UInt<4>}}
    
    io.debugPort.fallFifo is invalid @[RgmiiTransfer.scala 27:6]
    io.debugPort.riseFifo is invalid @[RgmiiTransfer.scala 27:6]
    io.debugPort.rxData is invalid @[RgmiiTransfer.scala 27:6]
    io.debugPort.rxValid is invalid @[RgmiiTransfer.scala 27:6]
    io.debugPort.rgmiiRxData is invalid @[RgmiiTransfer.scala 27:6]
    io.debugPort.rgmiiRxCtrl is invalid @[RgmiiTransfer.scala 27:6]
    io.debugPort.rgmiiRxClock is invalid @[RgmiiTransfer.scala 27:6]
    io.tx.bits is invalid @[RgmiiTransfer.scala 27:6]
    io.tx.valid is invalid @[RgmiiTransfer.scala 27:6]
    io.rx.bits is invalid @[RgmiiTransfer.scala 27:6]
    io.rx.valid is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.ereset is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.rxCtrl is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.rxData is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.rxClock is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.txCtrl is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.txData is invalid @[RgmiiTransfer.scala 27:6]
    io.rgmii.txClock is invalid @[RgmiiTransfer.scala 27:6]
    inst phasePll of FpgaPhasePll @[RgmiiTransfer.scala 29:24]
    phasePll.clk_p270 is invalid
    phasePll.clk_p225 is invalid
    phasePll.clk_p180 is invalid
    phasePll.clk_p90 is invalid
    phasePll.clk_p45 is invalid
    phasePll.reset is invalid
    phasePll.clk_in is invalid
    inst topHalfFifo of FpgaFifo @[RgmiiTransfer.scala 30:27]
    topHalfFifo.empty is invalid
    topHalfFifo.full is invalid
    topHalfFifo.dout is invalid
    topHalfFifo.rd_en is invalid
    topHalfFifo.wr_en is invalid
    topHalfFifo.din is invalid
    topHalfFifo.rd_clk is invalid
    topHalfFifo.wr_clk is invalid
    topHalfFifo.rst is invalid
    inst bottomHalfFifo of FpgaFifo_1 @[RgmiiTransfer.scala 31:30]
    bottomHalfFifo.empty is invalid
    bottomHalfFifo.full is invalid
    bottomHalfFifo.dout is invalid
    bottomHalfFifo.rd_en is invalid
    bottomHalfFifo.wr_en is invalid
    bottomHalfFifo.din is invalid
    bottomHalfFifo.rd_clk is invalid
    bottomHalfFifo.wr_clk is invalid
    bottomHalfFifo.rst is invalid
    node _phasePll_io_clk_in_T = asClock(io.rgmii.rxClock) @[RgmiiTransfer.scala 33:49]
    phasePll.clk_in <= _phasePll_io_clk_in_T @[RgmiiTransfer.scala 33:22]
    topHalfFifo.rst <= reset @[RgmiiTransfer.scala 35:22]
    bottomHalfFifo.rst <= reset @[RgmiiTransfer.scala 36:25]
    topHalfFifo.wr_clk <= phasePll.clk_p45 @[RgmiiTransfer.scala 38:25]
    topHalfFifo.wr_en <= io.rgmii.rxCtrl @[RgmiiTransfer.scala 39:24]
    topHalfFifo.din <= io.rgmii.rxData @[RgmiiTransfer.scala 40:22]
    topHalfFifo.rd_clk <= clock @[RgmiiTransfer.scala 41:25]
    topHalfFifo.rd_en <= io.rx.valid @[RgmiiTransfer.scala 42:24]
    bottomHalfFifo.wr_clk <= phasePll.clk_p225 @[RgmiiTransfer.scala 44:28]
    bottomHalfFifo.wr_en <= io.rgmii.rxCtrl @[RgmiiTransfer.scala 45:27]
    bottomHalfFifo.din <= io.rgmii.rxData @[RgmiiTransfer.scala 46:25]
    bottomHalfFifo.rd_clk <= clock @[RgmiiTransfer.scala 47:28]
    bottomHalfFifo.rd_en <= io.rx.valid @[RgmiiTransfer.scala 48:27]
    node _notEmpty_T = eq(topHalfFifo.empty, UInt<1>("h00")) @[RgmiiTransfer.scala 50:18]
    node _notEmpty_T_1 = eq(bottomHalfFifo.empty, UInt<1>("h00")) @[RgmiiTransfer.scala 50:43]
    node notEmpty = and(_notEmpty_T, _notEmpty_T_1) @[RgmiiTransfer.scala 50:40]
    reg io_rx_valid_REG : UInt<1>, clock @[RgmiiTransfer.scala 51:41]
    io_rx_valid_REG <= notEmpty @[RgmiiTransfer.scala 51:41]
    reg io_rx_valid_REG_1 : UInt<1>, clock @[RgmiiTransfer.scala 51:33]
    io_rx_valid_REG_1 <= io_rx_valid_REG @[RgmiiTransfer.scala 51:33]
    reg io_rx_valid_REG_2 : UInt<1>, clock @[RgmiiTransfer.scala 51:25]
    io_rx_valid_REG_2 <= io_rx_valid_REG_1 @[RgmiiTransfer.scala 51:25]
    node _io_rx_valid_T = and(io_rx_valid_REG_2, notEmpty) @[RgmiiTransfer.scala 51:54]
    io.rx.valid <= _io_rx_valid_T @[RgmiiTransfer.scala 51:15]
    node _io_rx_bits_T = cat(topHalfFifo.dout, bottomHalfFifo.dout) @[Cat.scala 30:58]
    io.rx.bits <= _io_rx_bits_T @[RgmiiTransfer.scala 52:14]
    io.debugPort.rgmiiRxCtrl <= io.rgmii.rxCtrl @[RgmiiTransfer.scala 55:28]
    io.debugPort.rgmiiRxData <= io.rgmii.rxData @[RgmiiTransfer.scala 56:28]
    io.debugPort.rxValid <= io.rx.valid @[RgmiiTransfer.scala 57:24]
    io.debugPort.rxData <= io.rx.bits @[RgmiiTransfer.scala 58:23]
    io.debugPort.riseFifo <= bottomHalfFifo.dout @[RgmiiTransfer.scala 59:25]
    io.debugPort.fallFifo <= topHalfFifo.dout @[RgmiiTransfer.scala 60:25]
    
  module Queue : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {info : UInt<8>, startAddress : UInt<12>, endAddress : UInt<12>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {info : UInt<8>, startAddress : UInt<12>, endAddress : UInt<12>}}, count : UInt<6>}
    
    cmem ram : {info : UInt<8>, startAddress : UInt<12>, endAddress : UInt<12>}[32] @[Decoupled.scala 218:16]
    reg value : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.endAddress <= io.enq.bits.endAddress @[Decoupled.scala 230:24]
      MPORT.startAddress <= io.enq.bits.startAddress @[Decoupled.scala 230:24]
      MPORT.info <= io.enq.bits.info @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<5>("h01f")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<5>("h01f")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.endAddress <= io_deq_bits_MPORT.endAddress @[Decoupled.scala 242:15]
    io.deq.bits.startAddress <= io_deq_bits_MPORT.startAddress @[Decoupled.scala 242:15]
    io.deq.bits.info <= io_deq_bits_MPORT.info @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<6>("h020"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module MacReceive : 
    input clock : Clock
    input reset : Reset
    output io : {flip rx : {valid : UInt<1>, bits : UInt<8>}, mac2IpIf : {arpData : {valid : UInt<1>, bits : UInt<8>}, ipData : {valid : UInt<1>, bits : UInt<8>}}, mac2CrcIf : {crcData : {valid : UInt<1>, bits : UInt<8>}, flip crcDone : UInt<1>, flip crcErr : UInt<1>}, debugPort : {rxValid : UInt<1>, rxData : UInt<8>, state : UInt<8>, cnt : UInt<8>, macType : UInt<16>, macWriteEnable : UInt<1>, macWriteAddress : UInt<12>, macWriteData : UInt<8>, macReadEnable : UInt<1>, macReadAddress : UInt<12>, macReadData : UInt<8>, arpTxValid : UInt<1>, arpTxData : UInt<8>, ipTxValid : UInt<1>, ipTxData : UInt<8>, fifoInValid : UInt<1>, fifoInStart : UInt<12>, fifoInEnd : UInt<12>, fifoOutFire : UInt<1>, fifoOutStart : UInt<12>, fifoOutEnd : UInt<12>}}
    
    io.debugPort.fifoOutEnd is invalid @[MacReceive.scala 41:6]
    io.debugPort.fifoOutStart is invalid @[MacReceive.scala 41:6]
    io.debugPort.fifoOutFire is invalid @[MacReceive.scala 41:6]
    io.debugPort.fifoInEnd is invalid @[MacReceive.scala 41:6]
    io.debugPort.fifoInStart is invalid @[MacReceive.scala 41:6]
    io.debugPort.fifoInValid is invalid @[MacReceive.scala 41:6]
    io.debugPort.ipTxData is invalid @[MacReceive.scala 41:6]
    io.debugPort.ipTxValid is invalid @[MacReceive.scala 41:6]
    io.debugPort.arpTxData is invalid @[MacReceive.scala 41:6]
    io.debugPort.arpTxValid is invalid @[MacReceive.scala 41:6]
    io.debugPort.macReadData is invalid @[MacReceive.scala 41:6]
    io.debugPort.macReadAddress is invalid @[MacReceive.scala 41:6]
    io.debugPort.macReadEnable is invalid @[MacReceive.scala 41:6]
    io.debugPort.macWriteData is invalid @[MacReceive.scala 41:6]
    io.debugPort.macWriteAddress is invalid @[MacReceive.scala 41:6]
    io.debugPort.macWriteEnable is invalid @[MacReceive.scala 41:6]
    io.debugPort.macType is invalid @[MacReceive.scala 41:6]
    io.debugPort.cnt is invalid @[MacReceive.scala 41:6]
    io.debugPort.state is invalid @[MacReceive.scala 41:6]
    io.debugPort.rxData is invalid @[MacReceive.scala 41:6]
    io.debugPort.rxValid is invalid @[MacReceive.scala 41:6]
    io.mac2CrcIf.crcErr is invalid @[MacReceive.scala 41:6]
    io.mac2CrcIf.crcDone is invalid @[MacReceive.scala 41:6]
    io.mac2CrcIf.crcData.bits is invalid @[MacReceive.scala 41:6]
    io.mac2CrcIf.crcData.valid is invalid @[MacReceive.scala 41:6]
    io.mac2IpIf.ipData.bits is invalid @[MacReceive.scala 41:6]
    io.mac2IpIf.ipData.valid is invalid @[MacReceive.scala 41:6]
    io.mac2IpIf.arpData.bits is invalid @[MacReceive.scala 41:6]
    io.mac2IpIf.arpData.valid is invalid @[MacReceive.scala 41:6]
    io.rx.bits is invalid @[MacReceive.scala 41:6]
    io.rx.valid is invalid @[MacReceive.scala 41:6]
    reg macType : UInt<8>[2], clock @[MacReceive.scala 43:20]
    reg cnt_value : UInt<11>, clock with : (reset => (reset, UInt<11>("h00"))) @[Counter.scala 60:40]
    reg inStateReg : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[MacReceive.scala 48:27]
    wire stateShift : UInt<1> @[MacReceive.scala 49:24]
    stateShift <= UInt<1>("h00") @[MacReceive.scala 50:14]
    smem macData : UInt<8>[4096], undefined @[MacReceive.scala 52:28]
    reg macDataWriteAddress : UInt<12>, clock @[MacReceive.scala 53:32]
    wire macDataWriteEnable : UInt<1> @[MacReceive.scala 54:32]
    wire macDataWriteData : UInt<8> @[MacReceive.scala 55:30]
    wire macDataReadEnable : UInt<1> @[MacReceive.scala 56:31]
    reg macDataReadAddress : UInt<12>, clock @[MacReceive.scala 57:31]
    wire macDataReadData : UInt<8> @[MacReceive.scala 58:29]
    macDataWriteEnable <= UInt<1>("h00") @[MacReceive.scala 59:22]
    macDataReadEnable <= UInt<1>("h00") @[MacReceive.scala 60:21]
    when macDataWriteEnable : @[MacReceive.scala 61:29]
      write mport MPORT = macData[macDataWriteAddress], clock
      MPORT <= macDataWriteData
      skip @[MacReceive.scala 61:29]
    wire _macDataReadData_WIRE : UInt @[MacReceive.scala 62:34]
    _macDataReadData_WIRE is invalid @[MacReceive.scala 62:34]
    when macDataReadEnable : @[MacReceive.scala 62:34]
      _macDataReadData_WIRE <= macDataReadAddress @[MacReceive.scala 62:34]
      node _macDataReadData_T = or(_macDataReadData_WIRE, UInt<12>("h00")) @[MacReceive.scala 62:34]
      node _macDataReadData_T_1 = bits(_macDataReadData_T, 11, 0) @[MacReceive.scala 62:34]
      read mport macDataReadData_MPORT = macData[_macDataReadData_T_1], clock @[MacReceive.scala 62:34]
      skip @[MacReceive.scala 62:34]
    macDataReadData <= macDataReadData_MPORT @[MacReceive.scala 62:19]
    macDataWriteData <= io.rx.bits @[MacReceive.scala 63:20]
    wire inMetaFifoIf : {flip ready : UInt<1>, valid : UInt<1>, bits : {info : UInt<8>, startAddress : UInt<12>, endAddress : UInt<12>}} @[MacReceive.scala 71:26]
    inst metaFifo of Queue @[Decoupled.scala 296:21]
    metaFifo.clock <= clock
    metaFifo.reset <= reset
    metaFifo.io.enq.valid <= inMetaFifoIf.valid @[Decoupled.scala 297:22]
    metaFifo.io.enq.bits.endAddress <= inMetaFifoIf.bits.endAddress @[Decoupled.scala 298:21]
    metaFifo.io.enq.bits.startAddress <= inMetaFifoIf.bits.startAddress @[Decoupled.scala 298:21]
    metaFifo.io.enq.bits.info <= inMetaFifoIf.bits.info @[Decoupled.scala 298:21]
    inMetaFifoIf.ready <= metaFifo.io.enq.ready @[Decoupled.scala 299:17]
    reg inStartAddress : UInt<12>, clock with : (reset => (reset, UInt<12>("h00"))) @[MacReceive.scala 73:31]
    reg inEndAddress : UInt<12>, clock with : (reset => (reset, UInt<12>("h00"))) @[MacReceive.scala 74:29]
    inMetaFifoIf.valid <= UInt<1>("h00") @[MacReceive.scala 75:22]
    node inMetaFifoIf_bits_hi = cat(UInt<1>("h00"), inStartAddress) @[Cat.scala 30:58]
    node _inMetaFifoIf_bits_T = cat(inMetaFifoIf_bits_hi, inEndAddress) @[Cat.scala 30:58]
    wire _inMetaFifoIf_bits_WIRE : {info : UInt<8>, startAddress : UInt<12>, endAddress : UInt<12>} @[MacReceive.scala 76:71]
    wire _inMetaFifoIf_bits_WIRE_1 : UInt<32>
    _inMetaFifoIf_bits_WIRE_1 <= _inMetaFifoIf_bits_T
    node _inMetaFifoIf_bits_T_1 = bits(_inMetaFifoIf_bits_WIRE_1, 11, 0) @[MacReceive.scala 76:71]
    _inMetaFifoIf_bits_WIRE.endAddress <= _inMetaFifoIf_bits_T_1 @[MacReceive.scala 76:71]
    node _inMetaFifoIf_bits_T_2 = bits(_inMetaFifoIf_bits_WIRE_1, 23, 12) @[MacReceive.scala 76:71]
    _inMetaFifoIf_bits_WIRE.startAddress <= _inMetaFifoIf_bits_T_2 @[MacReceive.scala 76:71]
    node _inMetaFifoIf_bits_T_3 = bits(_inMetaFifoIf_bits_WIRE_1, 31, 24) @[MacReceive.scala 76:71]
    _inMetaFifoIf_bits_WIRE.info <= _inMetaFifoIf_bits_T_3 @[MacReceive.scala 76:71]
    inMetaFifoIf.bits.endAddress <= _inMetaFifoIf_bits_WIRE.endAddress @[MacReceive.scala 76:21]
    inMetaFifoIf.bits.startAddress <= _inMetaFifoIf_bits_WIRE.startAddress @[MacReceive.scala 76:21]
    inMetaFifoIf.bits.info <= _inMetaFifoIf_bits_WIRE.info @[MacReceive.scala 76:21]
    wire metaInfo : {info : UInt<8>, startAddress : UInt<12>, endAddress : UInt<12>} @[MacReceive.scala 77:40]
    node metaInfo_hi = cat(metaFifo.io.deq.bits.info, metaFifo.io.deq.bits.startAddress) @[MacReceive.scala 77:40]
    node _metaInfo_T = cat(metaInfo_hi, metaFifo.io.deq.bits.endAddress) @[MacReceive.scala 77:40]
    wire _metaInfo_WIRE : UInt<32>
    _metaInfo_WIRE <= _metaInfo_T
    node _metaInfo_T_1 = bits(_metaInfo_WIRE, 11, 0) @[MacReceive.scala 77:40]
    metaInfo.endAddress <= _metaInfo_T_1 @[MacReceive.scala 77:40]
    node _metaInfo_T_2 = bits(_metaInfo_WIRE, 23, 12) @[MacReceive.scala 77:40]
    metaInfo.startAddress <= _metaInfo_T_2 @[MacReceive.scala 77:40]
    node _metaInfo_T_3 = bits(_metaInfo_WIRE, 31, 24) @[MacReceive.scala 77:40]
    metaInfo.info <= _metaInfo_T_3 @[MacReceive.scala 77:40]
    node _outStartAddress_T = and(metaFifo.io.deq.ready, metaFifo.io.deq.valid) @[Decoupled.scala 40:37]
    reg outStartAddress : UInt<12>, clock @[Reg.scala 15:16]
    when _outStartAddress_T : @[Reg.scala 16:19]
      outStartAddress <= metaInfo.startAddress @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _outEndAddress_T = and(metaFifo.io.deq.ready, metaFifo.io.deq.valid) @[Decoupled.scala 40:37]
    reg outEndAddress : UInt<12>, clock @[Reg.scala 15:16]
    when _outEndAddress_T : @[Reg.scala 16:19]
      outEndAddress <= metaInfo.endAddress @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    stateShift <= UInt<1>("h00") @[MacReceive.scala 86:14]
    node _T = eq(UInt<4>("h00"), inStateReg) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      node _T_1 = eq(io.rx.bits, UInt<7>("h055")) @[MacReceive.scala 89:31]
      node _T_2 = and(io.rx.valid, _T_1) @[MacReceive.scala 89:21]
      when _T_2 : @[MacReceive.scala 89:44]
        node wrap = eq(cnt_value, UInt<11>("h05db")) @[Counter.scala 72:24]
        node _value_T = add(cnt_value, UInt<1>("h01")) @[Counter.scala 76:24]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
        cnt_value <= _value_T_1 @[Counter.scala 76:15]
        when wrap : @[Counter.scala 86:20]
          cnt_value <= UInt<1>("h00") @[Counter.scala 86:28]
          skip @[Counter.scala 86:20]
        stateShift <= UInt<1>("h01") @[MacReceive.scala 91:20]
        inStateReg <= UInt<4>("h01") @[MacReceive.scala 92:20]
        skip @[MacReceive.scala 89:44]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<4>("h01"), inStateReg) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        wire v : UInt<8>[8] @[package.scala 150:17]
        v[0] <= UInt<8>("h055") @[package.scala 152:12]
        v[1] <= UInt<8>("h055") @[package.scala 152:12]
        v[2] <= UInt<8>("h055") @[package.scala 152:12]
        v[3] <= UInt<8>("h055") @[package.scala 152:12]
        v[4] <= UInt<8>("h055") @[package.scala 152:12]
        v[5] <= UInt<8>("h055") @[package.scala 152:12]
        v[6] <= UInt<8>("h055") @[package.scala 152:12]
        v[7] <= UInt<8>("h0d5") @[package.scala 152:12]
        node _T_4 = bits(cnt_value, 2, 0)
        node _T_5 = eq(io.rx.bits, v[_T_4]) @[package.scala 93:50]
        node _T_6 = and(io.rx.valid, _T_5) @[package.scala 93:22]
        when _T_6 : @[package.scala 93:84]
          node wrap_1 = eq(cnt_value, UInt<11>("h05db")) @[Counter.scala 72:24]
          node _value_T_2 = add(cnt_value, UInt<1>("h01")) @[Counter.scala 76:24]
          node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
          cnt_value <= _value_T_3 @[Counter.scala 76:15]
          when wrap_1 : @[Counter.scala 86:20]
            cnt_value <= UInt<1>("h00") @[Counter.scala 86:28]
            skip @[Counter.scala 86:20]
          skip @[package.scala 93:84]
        else : @[package.scala 95:9]
          cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
          inStateReg <= UInt<4>("h00") @[package.scala 97:12]
          skip @[package.scala 95:9]
        node _T_7 = eq(cnt_value, UInt<3>("h07")) @[package.scala 99:23]
        when _T_7 : @[package.scala 99:40]
          cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
          stateShift <= UInt<1>("h01") @[package.scala 101:12]
          inStateReg <= UInt<4>("h02") @[package.scala 102:12]
          skip @[package.scala 99:40]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<4>("h02"), inStateReg) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          wire _WIRE : UInt<8>[6] @[package.scala 158:31]
          _WIRE[0] <= UInt<8>("h012") @[package.scala 158:31]
          _WIRE[1] <= UInt<8>("h034") @[package.scala 158:31]
          _WIRE[2] <= UInt<8>("h055") @[package.scala 158:31]
          _WIRE[3] <= UInt<8>("h0aa") @[package.scala 158:31]
          _WIRE[4] <= UInt<8>("h0ff") @[package.scala 158:31]
          _WIRE[5] <= UInt<8>("h00") @[package.scala 158:31]
          wire _WIRE_1 : UInt<8>[6] @[package.scala 158:31]
          _WIRE_1[0] <= UInt<8>("h0ff") @[package.scala 158:31]
          _WIRE_1[1] <= UInt<8>("h0ff") @[package.scala 158:31]
          _WIRE_1[2] <= UInt<8>("h0ff") @[package.scala 158:31]
          _WIRE_1[3] <= UInt<8>("h0ff") @[package.scala 158:31]
          _WIRE_1[4] <= UInt<8>("h0ff") @[package.scala 158:31]
          _WIRE_1[5] <= UInt<8>("h0ff") @[package.scala 158:31]
          node _T_9 = bits(cnt_value, 2, 0)
          node _T_10 = eq(io.rx.bits, _WIRE[_T_9]) @[package.scala 93:50]
          node _T_11 = bits(cnt_value, 2, 0)
          node _T_12 = eq(io.rx.bits, _WIRE_1[_T_11]) @[package.scala 93:50]
          node _T_13 = or(_T_10, _T_12) @[package.scala 93:77]
          node _T_14 = and(io.rx.valid, _T_13) @[package.scala 93:22]
          when _T_14 : @[package.scala 93:84]
            node wrap_2 = eq(cnt_value, UInt<11>("h05db")) @[Counter.scala 72:24]
            node _value_T_4 = add(cnt_value, UInt<1>("h01")) @[Counter.scala 76:24]
            node _value_T_5 = tail(_value_T_4, 1) @[Counter.scala 76:24]
            cnt_value <= _value_T_5 @[Counter.scala 76:15]
            when wrap_2 : @[Counter.scala 86:20]
              cnt_value <= UInt<1>("h00") @[Counter.scala 86:28]
              skip @[Counter.scala 86:20]
            skip @[package.scala 93:84]
          else : @[package.scala 95:9]
            cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
            inStateReg <= UInt<4>("h00") @[package.scala 97:12]
            skip @[package.scala 95:9]
          node _T_15 = eq(cnt_value, UInt<3>("h05")) @[package.scala 99:23]
          when _T_15 : @[package.scala 99:40]
            cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
            stateShift <= UInt<1>("h01") @[package.scala 101:12]
            inStateReg <= UInt<4>("h03") @[package.scala 102:12]
            skip @[package.scala 99:40]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_16 = eq(UInt<4>("h03"), inStateReg) @[Conditional.scala 37:30]
          when _T_16 : @[Conditional.scala 39:67]
            when io.rx.valid : @[package.scala 127:24]
              node wrap_3 = eq(cnt_value, UInt<11>("h05db")) @[Counter.scala 72:24]
              node _value_T_6 = add(cnt_value, UInt<1>("h01")) @[Counter.scala 76:24]
              node _value_T_7 = tail(_value_T_6, 1) @[Counter.scala 76:24]
              cnt_value <= _value_T_7 @[Counter.scala 76:15]
              when wrap_3 : @[Counter.scala 86:20]
                cnt_value <= UInt<1>("h00") @[Counter.scala 86:28]
                skip @[Counter.scala 86:20]
              node _T_17 = eq(cnt_value, UInt<3>("h05")) @[package.scala 129:26]
              when _T_17 : @[package.scala 129:41]
                cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
                stateShift <= UInt<1>("h01") @[package.scala 131:16]
                inStateReg <= UInt<4>("h04") @[package.scala 132:16]
                skip @[package.scala 129:41]
              skip @[package.scala 127:24]
            else : @[package.scala 134:11]
              cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
              inStateReg <= UInt<4>("h00") @[package.scala 136:14]
              skip @[package.scala 134:11]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_18 = eq(UInt<4>("h04"), inStateReg) @[Conditional.scala 37:30]
            when _T_18 : @[Conditional.scala 39:67]
              node _T_19 = eq(UInt<1>("h00"), cnt_value) @[package.scala 108:30]
              node _T_20 = and(io.rx.valid, _T_19) @[package.scala 108:23]
              when _T_20 : @[package.scala 108:45]
                macType[UInt<1>("h01")] <= io.rx.bits @[package.scala 109:35]
                skip @[package.scala 108:45]
              node _T_21 = eq(UInt<1>("h01"), cnt_value) @[package.scala 108:30]
              node _T_22 = and(io.rx.valid, _T_21) @[package.scala 108:23]
              when _T_22 : @[package.scala 108:45]
                macType[UInt<1>("h00")] <= io.rx.bits @[package.scala 109:35]
                skip @[package.scala 108:45]
              when io.rx.valid : @[package.scala 112:23]
                node wrap_4 = eq(cnt_value, UInt<11>("h05db")) @[Counter.scala 72:24]
                node _value_T_8 = add(cnt_value, UInt<1>("h01")) @[Counter.scala 76:24]
                node _value_T_9 = tail(_value_T_8, 1) @[Counter.scala 76:24]
                cnt_value <= _value_T_9 @[Counter.scala 76:15]
                when wrap_4 : @[Counter.scala 86:20]
                  cnt_value <= UInt<1>("h00") @[Counter.scala 86:28]
                  skip @[Counter.scala 86:20]
                node _T_23 = eq(cnt_value, UInt<1>("h01")) @[package.scala 114:24]
                when _T_23 : @[package.scala 114:46]
                  cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
                  stateShift <= UInt<1>("h01") @[package.scala 116:14]
                  inStateReg <= UInt<4>("h05") @[package.scala 117:14]
                  skip @[package.scala 114:46]
                skip @[package.scala 112:23]
              else : @[package.scala 119:9]
                cnt_value <= UInt<1>("h00") @[Counter.scala 97:11]
                inStateReg <= UInt<4>("h00") @[package.scala 121:12]
                skip @[package.scala 119:9]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_24 = eq(UInt<4>("h05"), inStateReg) @[Conditional.scala 37:30]
              when _T_24 : @[Conditional.scala 39:67]
                node _T_25 = eq(io.rx.valid, UInt<1>("h00")) @[package.scala 139:15]
                when _T_25 : @[package.scala 139:26]
                  stateShift <= UInt<1>("h01") @[package.scala 140:14]
                  inStateReg <= UInt<4>("h06") @[package.scala 141:14]
                  skip @[package.scala 139:26]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_26 = eq(UInt<4>("h06"), inStateReg) @[Conditional.scala 37:30]
                when _T_26 : @[Conditional.scala 39:67]
                  inStateReg <= UInt<4>("h00") @[MacReceive.scala 111:18]
                  skip @[Conditional.scala 39:67]
    node _T_27 = eq(inStateReg, UInt<4>("h04")) @[MacReceive.scala 115:20]
    node _T_28 = and(_T_27, stateShift) @[MacReceive.scala 115:30]
    when _T_28 : @[MacReceive.scala 115:45]
      node _macDataWriteAddress_T = add(inEndAddress, UInt<1>("h01")) @[MacReceive.scala 116:41]
      node _macDataWriteAddress_T_1 = tail(_macDataWriteAddress_T, 1) @[MacReceive.scala 116:41]
      macDataWriteAddress <= _macDataWriteAddress_T_1 @[MacReceive.scala 116:25]
      node _lo_T = add(inEndAddress, UInt<1>("h01")) @[MacReceive.scala 117:36]
      node _lo_T_1 = tail(_lo_T, 1) @[MacReceive.scala 117:36]
      inStartAddress <= _lo_T_1 @[MacReceive.scala 117:20]
      skip @[MacReceive.scala 115:45]
    node _T_29 = eq(inStateReg, UInt<4>("h05")) @[MacReceive.scala 119:20]
    when _T_29 : @[MacReceive.scala 119:31]
      node _macDataWriteAddress_T_2 = add(macDataWriteAddress, UInt<1>("h01")) @[MacReceive.scala 120:48]
      node _macDataWriteAddress_T_3 = tail(_macDataWriteAddress_T_2, 1) @[MacReceive.scala 120:48]
      macDataWriteAddress <= _macDataWriteAddress_T_3 @[MacReceive.scala 120:25]
      when stateShift : @[MacReceive.scala 121:23]
        node _lo_T_2 = sub(macDataWriteAddress, UInt<1>("h01")) @[MacReceive.scala 121:61]
        node _lo_T_3 = tail(_lo_T_2, 1) @[MacReceive.scala 121:61]
        inEndAddress <= _lo_T_3 @[MacReceive.scala 121:38]
        skip @[MacReceive.scala 121:23]
      skip @[MacReceive.scala 119:31]
    node _T_30 = eq(inStateReg, UInt<4>("h06")) @[MacReceive.scala 123:20]
    when _T_30 : @[MacReceive.scala 123:31]
      inMetaFifoIf.valid <= UInt<1>("h01") @[MacReceive.scala 124:24]
      skip @[MacReceive.scala 123:31]
    node _T_31 = cat(macType[1], macType[0]) @[MacReceive.scala 128:23]
    node _T_32 = eq(_T_31, UInt<32>("h0800")) @[MacReceive.scala 128:26]
    when _T_32 : @[MacReceive.scala 128:41]
      inMetaFifoIf.valid <= UInt<1>("h00") @[MacReceive.scala 128:62]
      skip @[MacReceive.scala 128:41]
    node _macDataWriteEnable_T = eq(inStateReg, UInt<4>("h05")) @[MacReceive.scala 130:36]
    node _macDataWriteEnable_T_1 = and(_macDataWriteEnable_T, io.rx.valid) @[MacReceive.scala 130:46]
    macDataWriteEnable <= _macDataWriteEnable_T_1 @[MacReceive.scala 130:22]
    reg outStateReg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[MacReceive.scala 133:28]
    node _T_33 = eq(UInt<3>("h00"), outStateReg) @[Conditional.scala 37:30]
    when _T_33 : @[Conditional.scala 40:58]
      node _T_34 = and(metaFifo.io.deq.ready, metaFifo.io.deq.valid) @[Decoupled.scala 40:37]
      when _T_34 : @[MacReceive.scala 136:30]
        outStateReg <= UInt<3>("h01") @[MacReceive.scala 137:21]
        macDataReadAddress <= metaInfo.startAddress @[MacReceive.scala 138:28]
        skip @[MacReceive.scala 136:30]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_35 = eq(UInt<3>("h01"), outStateReg) @[Conditional.scala 37:30]
      when _T_35 : @[Conditional.scala 39:67]
        node _macDataReadAddress_T = add(macDataReadAddress, UInt<1>("h01")) @[MacReceive.scala 142:48]
        node _macDataReadAddress_T_1 = tail(_macDataReadAddress_T, 1) @[MacReceive.scala 142:48]
        macDataReadAddress <= _macDataReadAddress_T_1 @[MacReceive.scala 142:26]
        node _T_36 = eq(macDataReadAddress, outEndAddress) @[MacReceive.scala 143:32]
        when _T_36 : @[MacReceive.scala 143:51]
          outStateReg <= UInt<3>("h02") @[MacReceive.scala 144:21]
          skip @[MacReceive.scala 143:51]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_37 = eq(UInt<3>("h02"), outStateReg) @[Conditional.scala 37:30]
        when _T_37 : @[Conditional.scala 39:67]
          outStateReg <= UInt<3>("h00") @[MacReceive.scala 148:19]
          skip @[Conditional.scala 39:67]
    node _metaFifo_io_deq_ready_T = eq(outStateReg, UInt<3>("h00")) @[MacReceive.scala 152:33]
    metaFifo.io.deq.ready <= _metaFifo_io_deq_ready_T @[MacReceive.scala 152:18]
    node _macDataReadEnable_T = eq(outStateReg, UInt<3>("h01")) @[MacReceive.scala 153:36]
    macDataReadEnable <= _macDataReadEnable_T @[MacReceive.scala 153:21]
    io.mac2IpIf.arpData.bits <= macDataReadData @[MacReceive.scala 155:28]
    node _io_mac2IpIf_arpData_valid_T = eq(outStateReg, UInt<3>("h01")) @[MacReceive.scala 156:52]
    node _io_mac2IpIf_arpData_valid_T_1 = cat(macType[1], macType[0]) @[MacReceive.scala 156:79]
    node _io_mac2IpIf_arpData_valid_T_2 = eq(_io_mac2IpIf_arpData_valid_T_1, UInt<32>("h0806")) @[MacReceive.scala 156:82]
    node _io_mac2IpIf_arpData_valid_T_3 = and(_io_mac2IpIf_arpData_valid_T, _io_mac2IpIf_arpData_valid_T_2) @[MacReceive.scala 156:62]
    reg io_mac2IpIf_arpData_valid_REG : UInt<1>, clock @[MacReceive.scala 156:39]
    io_mac2IpIf_arpData_valid_REG <= _io_mac2IpIf_arpData_valid_T_3 @[MacReceive.scala 156:39]
    io.mac2IpIf.arpData.valid <= io_mac2IpIf_arpData_valid_REG @[MacReceive.scala 156:29]
    io.mac2IpIf.ipData.bits <= macDataReadData @[MacReceive.scala 157:27]
    node _io_mac2IpIf_ipData_valid_T = eq(outStateReg, UInt<3>("h01")) @[MacReceive.scala 158:51]
    node _io_mac2IpIf_ipData_valid_T_1 = cat(macType[1], macType[0]) @[MacReceive.scala 158:78]
    node _io_mac2IpIf_ipData_valid_T_2 = eq(_io_mac2IpIf_ipData_valid_T_1, UInt<32>("h0800")) @[MacReceive.scala 158:81]
    node _io_mac2IpIf_ipData_valid_T_3 = and(_io_mac2IpIf_ipData_valid_T, _io_mac2IpIf_ipData_valid_T_2) @[MacReceive.scala 158:61]
    reg io_mac2IpIf_ipData_valid_REG : UInt<1>, clock @[MacReceive.scala 158:38]
    io_mac2IpIf_ipData_valid_REG <= _io_mac2IpIf_ipData_valid_T_3 @[MacReceive.scala 158:38]
    io.mac2IpIf.ipData.valid <= io_mac2IpIf_ipData_valid_REG @[MacReceive.scala 158:28]
    io.debugPort.state <= inStateReg @[MacReceive.scala 160:22]
    io.debugPort.cnt <= cnt_value @[MacReceive.scala 161:20]
    io.debugPort.rxValid <= io.rx.valid @[MacReceive.scala 162:24]
    io.debugPort.rxData <= io.rx.bits @[MacReceive.scala 163:23]
    wire _io_debugPort_macType_WIRE : UInt<16> @[MacReceive.scala 164:43]
    node _io_debugPort_macType_T = cat(macType[1], macType[0]) @[MacReceive.scala 164:43]
    _io_debugPort_macType_WIRE <= _io_debugPort_macType_T @[MacReceive.scala 164:43]
    io.debugPort.macType <= _io_debugPort_macType_WIRE @[MacReceive.scala 164:24]
    io.debugPort.macWriteEnable <= macDataWriteEnable @[MacReceive.scala 165:31]
    io.debugPort.macWriteAddress <= macDataWriteAddress @[MacReceive.scala 166:32]
    io.debugPort.macWriteData <= macDataWriteData @[MacReceive.scala 167:29]
    io.debugPort.fifoInValid <= inMetaFifoIf.valid @[MacReceive.scala 168:28]
    io.debugPort.fifoInStart <= inStartAddress @[MacReceive.scala 169:28]
    io.debugPort.fifoInEnd <= inEndAddress @[MacReceive.scala 170:26]
    io.debugPort.macReadEnable <= macDataReadEnable @[MacReceive.scala 171:30]
    io.debugPort.macReadAddress <= macDataReadAddress @[MacReceive.scala 172:31]
    io.debugPort.macReadData <= macDataReadData @[MacReceive.scala 173:28]
    node _io_debugPort_fifoOutFire_T = and(metaFifo.io.deq.ready, metaFifo.io.deq.valid) @[Decoupled.scala 40:37]
    io.debugPort.fifoOutFire <= _io_debugPort_fifoOutFire_T @[MacReceive.scala 174:28]
    io.debugPort.fifoOutStart <= metaInfo.startAddress @[MacReceive.scala 175:29]
    io.debugPort.fifoOutEnd <= metaInfo.endAddress @[MacReceive.scala 176:27]
    io.debugPort.arpTxValid <= io.mac2IpIf.arpData.valid @[MacReceive.scala 177:27]
    io.debugPort.arpTxData <= io.mac2IpIf.arpData.bits @[MacReceive.scala 178:26]
    io.debugPort.ipTxValid <= io.mac2IpIf.ipData.valid @[MacReceive.scala 179:26]
    io.debugPort.ipTxData <= io.mac2IpIf.ipData.bits @[MacReceive.scala 180:25]
    
  module Queue_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>}, count : UInt<5>}
    
    cmem ram : UInt<81>[16] @[Decoupled.scala 218:16]
    reg value : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<4>("h0f")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<4>("h0f")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h010"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>}, count : UInt<5>}
    
    cmem ram : UInt<81>[16] @[Decoupled.scala 218:16]
    reg value : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<4>("h0f")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<4>("h0f")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h010"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Arbiter : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt}[2], out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt}, chosen : UInt<1>}
    
    io.chosen <= UInt<1>("h01") @[Arbiter.scala 123:13]
    io.out.bits <= io.in[1].bits @[Arbiter.scala 124:15]
    when io.in[0].valid : @[Arbiter.scala 126:27]
      io.chosen <= UInt<1>("h00") @[Arbiter.scala 127:17]
      io.out.bits <= io.in[0].bits @[Arbiter.scala 128:19]
      skip @[Arbiter.scala 126:27]
    node grant_1 = eq(io.in[0].valid, UInt<1>("h00")) @[Arbiter.scala 31:78]
    node _io_in_0_ready_T = and(UInt<1>("h01"), io.out.ready) @[Arbiter.scala 134:19]
    io.in[0].ready <= _io_in_0_ready_T @[Arbiter.scala 134:14]
    node _io_in_1_ready_T = and(grant_1, io.out.ready) @[Arbiter.scala 134:19]
    io.in[1].ready <= _io_in_1_ready_T @[Arbiter.scala 134:14]
    node _io_out_valid_T = eq(grant_1, UInt<1>("h00")) @[Arbiter.scala 135:19]
    node _io_out_valid_T_1 = or(_io_out_valid_T, io.in[1].valid) @[Arbiter.scala 135:31]
    io.out.valid <= _io_out_valid_T_1 @[Arbiter.scala 135:16]
    
  module Arp : 
    input clock : Clock
    input reset : Reset
    output io : {flip mac2Arp : {valid : UInt<1>, bits : UInt<8>}, arp2Mac : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip ip2Arp : {queryReq : {valid : UInt<1>, bits : UInt<32>}, flip queryResp : {valid : UInt<1>, bits : UInt<48>}, sendReq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}}, debugPort : {op : UInt<16>, macSrc : UInt<48>, ipSrc : UInt<32>, macDest : UInt<48>, ipDest : UInt<32>, ramWriteEnable : UInt<1>, ramWriteAddr : UInt<8>, ramWriteIp : UInt<32>, ramWriteMac : UInt<48>, arpOutValid : UInt<1>, arpOutData : UInt<8>}}
    
    io.debugPort.arpOutData is invalid @[Arp.scala 34:6]
    io.debugPort.arpOutValid is invalid @[Arp.scala 34:6]
    io.debugPort.ramWriteMac is invalid @[Arp.scala 34:6]
    io.debugPort.ramWriteIp is invalid @[Arp.scala 34:6]
    io.debugPort.ramWriteAddr is invalid @[Arp.scala 34:6]
    io.debugPort.ramWriteEnable is invalid @[Arp.scala 34:6]
    io.debugPort.ipDest is invalid @[Arp.scala 34:6]
    io.debugPort.macDest is invalid @[Arp.scala 34:6]
    io.debugPort.ipSrc is invalid @[Arp.scala 34:6]
    io.debugPort.macSrc is invalid @[Arp.scala 34:6]
    io.debugPort.op is invalid @[Arp.scala 34:6]
    io.ip2Arp.sendReq.bits is invalid @[Arp.scala 34:6]
    io.ip2Arp.sendReq.valid is invalid @[Arp.scala 34:6]
    io.ip2Arp.sendReq.ready is invalid @[Arp.scala 34:6]
    io.ip2Arp.queryResp.bits is invalid @[Arp.scala 34:6]
    io.ip2Arp.queryResp.valid is invalid @[Arp.scala 34:6]
    io.ip2Arp.queryReq.bits is invalid @[Arp.scala 34:6]
    io.ip2Arp.queryReq.valid is invalid @[Arp.scala 34:6]
    io.arp2Mac.bits is invalid @[Arp.scala 34:6]
    io.arp2Mac.valid is invalid @[Arp.scala 34:6]
    io.arp2Mac.ready is invalid @[Arp.scala 34:6]
    io.mac2Arp.bits is invalid @[Arp.scala 34:6]
    io.mac2Arp.valid is invalid @[Arp.scala 34:6]
    smem arpRam : {ip : UInt<32>, mac : UInt<48>}[256], undefined @[Arp.scala 36:27]
    wire arpRamWriteEnable : UInt<1> @[Arp.scala 37:31]
    reg arpRamWriteAddress : UInt<8>, clock @[Arp.scala 38:31]
    reg arpRamWriteData : {ip : UInt<32>, mac : UInt<48>}, clock @[Arp.scala 39:28]
    wire arpRamReadEnable : UInt<1> @[Arp.scala 40:30]
    wire arpRamReadAddress : UInt<8> @[Arp.scala 41:31]
    wire arpRamReadData : {ip : UInt<32>, mac : UInt<48>} @[Arp.scala 42:28]
    when arpRamWriteEnable : @[Arp.scala 43:28]
      write mport MPORT = arpRam[arpRamWriteAddress], clock
      MPORT.mac <= arpRamWriteData.mac
      MPORT.ip <= arpRamWriteData.ip
      skip @[Arp.scala 43:28]
    wire _arpRamReadData_WIRE : UInt @[Arp.scala 44:32]
    _arpRamReadData_WIRE is invalid @[Arp.scala 44:32]
    when arpRamReadEnable : @[Arp.scala 44:32]
      _arpRamReadData_WIRE <= arpRamReadAddress @[Arp.scala 44:32]
      node _arpRamReadData_T = or(_arpRamReadData_WIRE, UInt<8>("h00")) @[Arp.scala 44:32]
      node _arpRamReadData_T_1 = bits(_arpRamReadData_T, 7, 0) @[Arp.scala 44:32]
      read mport arpRamReadData_MPORT = arpRam[_arpRamReadData_T_1], clock @[Arp.scala 44:32]
      skip @[Arp.scala 44:32]
    arpRamReadData.mac <= arpRamReadData_MPORT.mac @[Arp.scala 44:18]
    arpRamReadData.ip <= arpRamReadData_MPORT.ip @[Arp.scala 44:18]
    reg value : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Counter.scala 60:40]
    reg op : UInt<8>[2], clock @[Arp.scala 47:15]
    reg macSrc : UInt<8>[6], clock @[Arp.scala 48:19]
    reg ipSrc : UInt<8>[4], clock @[Arp.scala 49:18]
    reg macDest : UInt<8>[6], clock @[Arp.scala 50:20]
    reg ipDest : UInt<8>[4], clock @[Arp.scala 51:19]
    reg st : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Arp.scala 54:25]
    wire shiftState : UInt<1> @[Arp.scala 56:24]
    shiftState <= UInt<1>("h00") @[Arp.scala 62:14]
    node _T = eq(UInt<4>("h00"), st) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      when io.mac2Arp.valid : @[Arp.scala 65:31]
        st <= UInt<4>("h01") @[Arp.scala 66:18]
        value <= UInt<1>("h00") @[Counter.scala 97:11]
        skip @[Arp.scala 65:31]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<4>("h01"), st) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        when io.mac2Arp.valid : @[package.scala 127:24]
          node wrap = eq(value, UInt<3>("h07")) @[Counter.scala 72:24]
          node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
          node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
          value <= _value_T_1 @[Counter.scala 76:15]
          node _T_2 = eq(value, UInt<3>("h04")) @[package.scala 129:26]
          when _T_2 : @[package.scala 129:41]
            value <= UInt<1>("h00") @[Counter.scala 97:11]
            shiftState <= UInt<1>("h01") @[package.scala 131:16]
            st <= UInt<4>("h02") @[package.scala 132:16]
            skip @[package.scala 129:41]
          skip @[package.scala 127:24]
        else : @[package.scala 134:11]
          value <= UInt<1>("h00") @[Counter.scala 97:11]
          st <= UInt<4>("h00") @[package.scala 136:14]
          skip @[package.scala 134:11]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_3 = eq(UInt<4>("h02"), st) @[Conditional.scala 37:30]
        when _T_3 : @[Conditional.scala 39:67]
          node _T_4 = eq(UInt<1>("h00"), value) @[package.scala 108:30]
          node _T_5 = and(io.mac2Arp.valid, _T_4) @[package.scala 108:23]
          when _T_5 : @[package.scala 108:45]
            op[UInt<1>("h01")] <= io.mac2Arp.bits @[package.scala 109:35]
            skip @[package.scala 108:45]
          node _T_6 = eq(UInt<1>("h01"), value) @[package.scala 108:30]
          node _T_7 = and(io.mac2Arp.valid, _T_6) @[package.scala 108:23]
          when _T_7 : @[package.scala 108:45]
            op[UInt<1>("h00")] <= io.mac2Arp.bits @[package.scala 109:35]
            skip @[package.scala 108:45]
          when io.mac2Arp.valid : @[package.scala 112:23]
            node wrap_1 = eq(value, UInt<3>("h07")) @[Counter.scala 72:24]
            node _value_T_2 = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
            node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
            value <= _value_T_3 @[Counter.scala 76:15]
            node _T_8 = eq(value, UInt<1>("h01")) @[package.scala 114:24]
            when _T_8 : @[package.scala 114:46]
              value <= UInt<1>("h00") @[Counter.scala 97:11]
              shiftState <= UInt<1>("h01") @[package.scala 116:14]
              st <= UInt<4>("h03") @[package.scala 117:14]
              skip @[package.scala 114:46]
            skip @[package.scala 112:23]
          else : @[package.scala 119:9]
            value <= UInt<1>("h00") @[Counter.scala 97:11]
            st <= UInt<4>("h00") @[package.scala 121:12]
            skip @[package.scala 119:9]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<4>("h03"), st) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _T_10 = eq(UInt<1>("h00"), value) @[package.scala 108:30]
            node _T_11 = and(io.mac2Arp.valid, _T_10) @[package.scala 108:23]
            when _T_11 : @[package.scala 108:45]
              macSrc[UInt<3>("h05")] <= io.mac2Arp.bits @[package.scala 109:35]
              skip @[package.scala 108:45]
            node _T_12 = eq(UInt<1>("h01"), value) @[package.scala 108:30]
            node _T_13 = and(io.mac2Arp.valid, _T_12) @[package.scala 108:23]
            when _T_13 : @[package.scala 108:45]
              macSrc[UInt<3>("h04")] <= io.mac2Arp.bits @[package.scala 109:35]
              skip @[package.scala 108:45]
            node _T_14 = eq(UInt<2>("h02"), value) @[package.scala 108:30]
            node _T_15 = and(io.mac2Arp.valid, _T_14) @[package.scala 108:23]
            when _T_15 : @[package.scala 108:45]
              macSrc[UInt<2>("h03")] <= io.mac2Arp.bits @[package.scala 109:35]
              skip @[package.scala 108:45]
            node _T_16 = eq(UInt<2>("h03"), value) @[package.scala 108:30]
            node _T_17 = and(io.mac2Arp.valid, _T_16) @[package.scala 108:23]
            when _T_17 : @[package.scala 108:45]
              macSrc[UInt<2>("h02")] <= io.mac2Arp.bits @[package.scala 109:35]
              skip @[package.scala 108:45]
            node _T_18 = eq(UInt<3>("h04"), value) @[package.scala 108:30]
            node _T_19 = and(io.mac2Arp.valid, _T_18) @[package.scala 108:23]
            when _T_19 : @[package.scala 108:45]
              macSrc[UInt<1>("h01")] <= io.mac2Arp.bits @[package.scala 109:35]
              skip @[package.scala 108:45]
            node _T_20 = eq(UInt<3>("h05"), value) @[package.scala 108:30]
            node _T_21 = and(io.mac2Arp.valid, _T_20) @[package.scala 108:23]
            when _T_21 : @[package.scala 108:45]
              macSrc[UInt<1>("h00")] <= io.mac2Arp.bits @[package.scala 109:35]
              skip @[package.scala 108:45]
            when io.mac2Arp.valid : @[package.scala 112:23]
              node wrap_2 = eq(value, UInt<3>("h07")) @[Counter.scala 72:24]
              node _value_T_4 = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
              node _value_T_5 = tail(_value_T_4, 1) @[Counter.scala 76:24]
              value <= _value_T_5 @[Counter.scala 76:15]
              node _T_22 = eq(value, UInt<3>("h05")) @[package.scala 114:24]
              when _T_22 : @[package.scala 114:46]
                value <= UInt<1>("h00") @[Counter.scala 97:11]
                shiftState <= UInt<1>("h01") @[package.scala 116:14]
                st <= UInt<4>("h04") @[package.scala 117:14]
                skip @[package.scala 114:46]
              skip @[package.scala 112:23]
            else : @[package.scala 119:9]
              value <= UInt<1>("h00") @[Counter.scala 97:11]
              st <= UInt<4>("h00") @[package.scala 121:12]
              skip @[package.scala 119:9]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_23 = eq(UInt<4>("h04"), st) @[Conditional.scala 37:30]
            when _T_23 : @[Conditional.scala 39:67]
              node _T_24 = eq(UInt<1>("h00"), value) @[package.scala 108:30]
              node _T_25 = and(io.mac2Arp.valid, _T_24) @[package.scala 108:23]
              when _T_25 : @[package.scala 108:45]
                ipSrc[UInt<2>("h03")] <= io.mac2Arp.bits @[package.scala 109:35]
                skip @[package.scala 108:45]
              node _T_26 = eq(UInt<1>("h01"), value) @[package.scala 108:30]
              node _T_27 = and(io.mac2Arp.valid, _T_26) @[package.scala 108:23]
              when _T_27 : @[package.scala 108:45]
                ipSrc[UInt<2>("h02")] <= io.mac2Arp.bits @[package.scala 109:35]
                skip @[package.scala 108:45]
              node _T_28 = eq(UInt<2>("h02"), value) @[package.scala 108:30]
              node _T_29 = and(io.mac2Arp.valid, _T_28) @[package.scala 108:23]
              when _T_29 : @[package.scala 108:45]
                ipSrc[UInt<1>("h01")] <= io.mac2Arp.bits @[package.scala 109:35]
                skip @[package.scala 108:45]
              node _T_30 = eq(UInt<2>("h03"), value) @[package.scala 108:30]
              node _T_31 = and(io.mac2Arp.valid, _T_30) @[package.scala 108:23]
              when _T_31 : @[package.scala 108:45]
                ipSrc[UInt<1>("h00")] <= io.mac2Arp.bits @[package.scala 109:35]
                skip @[package.scala 108:45]
              when io.mac2Arp.valid : @[package.scala 112:23]
                node wrap_3 = eq(value, UInt<3>("h07")) @[Counter.scala 72:24]
                node _value_T_6 = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
                node _value_T_7 = tail(_value_T_6, 1) @[Counter.scala 76:24]
                value <= _value_T_7 @[Counter.scala 76:15]
                node _T_32 = eq(value, UInt<2>("h03")) @[package.scala 114:24]
                when _T_32 : @[package.scala 114:46]
                  value <= UInt<1>("h00") @[Counter.scala 97:11]
                  shiftState <= UInt<1>("h01") @[package.scala 116:14]
                  st <= UInt<4>("h05") @[package.scala 117:14]
                  skip @[package.scala 114:46]
                skip @[package.scala 112:23]
              else : @[package.scala 119:9]
                value <= UInt<1>("h00") @[Counter.scala 97:11]
                st <= UInt<4>("h00") @[package.scala 121:12]
                skip @[package.scala 119:9]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_33 = eq(UInt<4>("h05"), st) @[Conditional.scala 37:30]
              when _T_33 : @[Conditional.scala 39:67]
                node _T_34 = eq(UInt<1>("h00"), value) @[package.scala 108:30]
                node _T_35 = and(io.mac2Arp.valid, _T_34) @[package.scala 108:23]
                when _T_35 : @[package.scala 108:45]
                  macDest[UInt<3>("h05")] <= io.mac2Arp.bits @[package.scala 109:35]
                  skip @[package.scala 108:45]
                node _T_36 = eq(UInt<1>("h01"), value) @[package.scala 108:30]
                node _T_37 = and(io.mac2Arp.valid, _T_36) @[package.scala 108:23]
                when _T_37 : @[package.scala 108:45]
                  macDest[UInt<3>("h04")] <= io.mac2Arp.bits @[package.scala 109:35]
                  skip @[package.scala 108:45]
                node _T_38 = eq(UInt<2>("h02"), value) @[package.scala 108:30]
                node _T_39 = and(io.mac2Arp.valid, _T_38) @[package.scala 108:23]
                when _T_39 : @[package.scala 108:45]
                  macDest[UInt<2>("h03")] <= io.mac2Arp.bits @[package.scala 109:35]
                  skip @[package.scala 108:45]
                node _T_40 = eq(UInt<2>("h03"), value) @[package.scala 108:30]
                node _T_41 = and(io.mac2Arp.valid, _T_40) @[package.scala 108:23]
                when _T_41 : @[package.scala 108:45]
                  macDest[UInt<2>("h02")] <= io.mac2Arp.bits @[package.scala 109:35]
                  skip @[package.scala 108:45]
                node _T_42 = eq(UInt<3>("h04"), value) @[package.scala 108:30]
                node _T_43 = and(io.mac2Arp.valid, _T_42) @[package.scala 108:23]
                when _T_43 : @[package.scala 108:45]
                  macDest[UInt<1>("h01")] <= io.mac2Arp.bits @[package.scala 109:35]
                  skip @[package.scala 108:45]
                node _T_44 = eq(UInt<3>("h05"), value) @[package.scala 108:30]
                node _T_45 = and(io.mac2Arp.valid, _T_44) @[package.scala 108:23]
                when _T_45 : @[package.scala 108:45]
                  macDest[UInt<1>("h00")] <= io.mac2Arp.bits @[package.scala 109:35]
                  skip @[package.scala 108:45]
                when io.mac2Arp.valid : @[package.scala 112:23]
                  node wrap_4 = eq(value, UInt<3>("h07")) @[Counter.scala 72:24]
                  node _value_T_8 = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
                  node _value_T_9 = tail(_value_T_8, 1) @[Counter.scala 76:24]
                  value <= _value_T_9 @[Counter.scala 76:15]
                  node _T_46 = eq(value, UInt<3>("h05")) @[package.scala 114:24]
                  when _T_46 : @[package.scala 114:46]
                    value <= UInt<1>("h00") @[Counter.scala 97:11]
                    shiftState <= UInt<1>("h01") @[package.scala 116:14]
                    st <= UInt<4>("h06") @[package.scala 117:14]
                    skip @[package.scala 114:46]
                  skip @[package.scala 112:23]
                else : @[package.scala 119:9]
                  value <= UInt<1>("h00") @[Counter.scala 97:11]
                  st <= UInt<4>("h00") @[package.scala 121:12]
                  skip @[package.scala 119:9]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_47 = eq(UInt<4>("h06"), st) @[Conditional.scala 37:30]
                when _T_47 : @[Conditional.scala 39:67]
                  node _T_48 = eq(UInt<1>("h00"), value) @[package.scala 108:30]
                  node _T_49 = and(io.mac2Arp.valid, _T_48) @[package.scala 108:23]
                  when _T_49 : @[package.scala 108:45]
                    ipDest[UInt<2>("h03")] <= io.mac2Arp.bits @[package.scala 109:35]
                    skip @[package.scala 108:45]
                  node _T_50 = eq(UInt<1>("h01"), value) @[package.scala 108:30]
                  node _T_51 = and(io.mac2Arp.valid, _T_50) @[package.scala 108:23]
                  when _T_51 : @[package.scala 108:45]
                    ipDest[UInt<2>("h02")] <= io.mac2Arp.bits @[package.scala 109:35]
                    skip @[package.scala 108:45]
                  node _T_52 = eq(UInt<2>("h02"), value) @[package.scala 108:30]
                  node _T_53 = and(io.mac2Arp.valid, _T_52) @[package.scala 108:23]
                  when _T_53 : @[package.scala 108:45]
                    ipDest[UInt<1>("h01")] <= io.mac2Arp.bits @[package.scala 109:35]
                    skip @[package.scala 108:45]
                  node _T_54 = eq(UInt<2>("h03"), value) @[package.scala 108:30]
                  node _T_55 = and(io.mac2Arp.valid, _T_54) @[package.scala 108:23]
                  when _T_55 : @[package.scala 108:45]
                    ipDest[UInt<1>("h00")] <= io.mac2Arp.bits @[package.scala 109:35]
                    skip @[package.scala 108:45]
                  when io.mac2Arp.valid : @[package.scala 112:23]
                    node wrap_5 = eq(value, UInt<3>("h07")) @[Counter.scala 72:24]
                    node _value_T_10 = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
                    node _value_T_11 = tail(_value_T_10, 1) @[Counter.scala 76:24]
                    value <= _value_T_11 @[Counter.scala 76:15]
                    node _T_56 = eq(value, UInt<2>("h03")) @[package.scala 114:24]
                    when _T_56 : @[package.scala 114:46]
                      value <= UInt<1>("h00") @[Counter.scala 97:11]
                      shiftState <= UInt<1>("h01") @[package.scala 116:14]
                      st <= UInt<4>("h07") @[package.scala 117:14]
                      skip @[package.scala 114:46]
                    skip @[package.scala 112:23]
                  else : @[package.scala 119:9]
                    value <= UInt<1>("h00") @[Counter.scala 97:11]
                    st <= UInt<4>("h00") @[package.scala 121:12]
                    skip @[package.scala 119:9]
                  skip @[Conditional.scala 39:67]
                else : @[Conditional.scala 39:67]
                  node _T_57 = eq(UInt<4>("h07"), st) @[Conditional.scala 37:30]
                  when _T_57 : @[Conditional.scala 39:67]
                    st <= UInt<4>("h00") @[Arp.scala 89:16]
                    skip @[Conditional.scala 39:67]
    node _arpRamWriteEnable_T = eq(st, UInt<4>("h07")) @[Arp.scala 93:33]
    arpRamWriteEnable <= _arpRamWriteEnable_T @[Arp.scala 93:21]
    arpRamWriteAddress <= macSrc[0] @[Arp.scala 94:22]
    wire _arpRamWriteData_ip_WIRE : UInt<32> @[Arp.scala 95:39]
    node arpRamWriteData_ip_lo = cat(ipSrc[1], ipSrc[0]) @[Arp.scala 95:39]
    node arpRamWriteData_ip_hi = cat(ipSrc[3], ipSrc[2]) @[Arp.scala 95:39]
    node _arpRamWriteData_ip_T = cat(arpRamWriteData_ip_hi, arpRamWriteData_ip_lo) @[Arp.scala 95:39]
    _arpRamWriteData_ip_WIRE <= _arpRamWriteData_ip_T @[Arp.scala 95:39]
    arpRamWriteData.ip <= _arpRamWriteData_ip_WIRE @[Arp.scala 95:22]
    wire _arpRamWriteData_mac_WIRE : UInt<48> @[Arp.scala 96:41]
    node arpRamWriteData_mac_lo_hi = cat(macSrc[2], macSrc[1]) @[Arp.scala 96:41]
    node arpRamWriteData_mac_lo = cat(arpRamWriteData_mac_lo_hi, macSrc[0]) @[Arp.scala 96:41]
    node arpRamWriteData_mac_hi_hi = cat(macSrc[5], macSrc[4]) @[Arp.scala 96:41]
    node arpRamWriteData_mac_hi = cat(arpRamWriteData_mac_hi_hi, macSrc[3]) @[Arp.scala 96:41]
    node _arpRamWriteData_mac_T = cat(arpRamWriteData_mac_hi, arpRamWriteData_mac_lo) @[Arp.scala 96:41]
    _arpRamWriteData_mac_WIRE <= _arpRamWriteData_mac_T @[Arp.scala 96:41]
    arpRamWriteData.mac <= _arpRamWriteData_mac_WIRE @[Arp.scala 96:23]
    arpRamReadEnable <= UInt<1>("h00") @[Arp.scala 98:20]
    arpRamReadAddress <= UInt<1>("h00") @[Arp.scala 99:21]
    wire arpReqIn : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>} @[Arp.scala 101:22]
    wire arpReqIn_bits_hi_lo : UInt<32> @[Arp.scala 102:46]
    node arpReqIn_bits_lo = cat(ipSrc[1], ipSrc[0]) @[Arp.scala 102:46]
    node arpReqIn_bits_hi = cat(ipSrc[3], ipSrc[2]) @[Arp.scala 102:46]
    node _arpReqIn_bits_T = cat(arpReqIn_bits_hi, arpReqIn_bits_lo) @[Arp.scala 102:46]
    arpReqIn_bits_hi_lo <= _arpReqIn_bits_T @[Arp.scala 102:46]
    wire arpReqIn_bits_lo_1 : UInt<48> @[Arp.scala 102:75]
    node arpReqIn_bits_lo_hi = cat(macSrc[2], macSrc[1]) @[Arp.scala 102:75]
    node arpReqIn_bits_lo_2 = cat(arpReqIn_bits_lo_hi, macSrc[0]) @[Arp.scala 102:75]
    node arpReqIn_bits_hi_hi = cat(macSrc[5], macSrc[4]) @[Arp.scala 102:75]
    node arpReqIn_bits_hi_1 = cat(arpReqIn_bits_hi_hi, macSrc[3]) @[Arp.scala 102:75]
    node _arpReqIn_bits_T_1 = cat(arpReqIn_bits_hi_1, arpReqIn_bits_lo_2) @[Arp.scala 102:75]
    arpReqIn_bits_lo_1 <= _arpReqIn_bits_T_1 @[Arp.scala 102:75]
    node arpReqIn_bits_hi_2 = cat(UInt<1>("h01"), arpReqIn_bits_hi_lo) @[Cat.scala 30:58]
    node _arpReqIn_bits_T_2 = cat(arpReqIn_bits_hi_2, arpReqIn_bits_lo_1) @[Cat.scala 30:58]
    arpReqIn.bits <= _arpReqIn_bits_T_2 @[Arp.scala 102:17]
    wire _arpReqIn_valid_WIRE : UInt @[Arp.scala 103:32]
    node _arpReqIn_valid_T = cat(op[1], op[0]) @[Arp.scala 103:32]
    _arpReqIn_valid_WIRE <= _arpReqIn_valid_T @[Arp.scala 103:32]
    node _arpReqIn_valid_T_1 = eq(_arpReqIn_valid_WIRE, UInt<16>("h01")) @[Arp.scala 103:41]
    node _arpReqIn_valid_T_2 = eq(st, UInt<4>("h07")) @[Arp.scala 103:74]
    reg arpReqIn_valid_REG : UInt<1>, clock @[Arp.scala 103:64]
    arpReqIn_valid_REG <= _arpReqIn_valid_T_2 @[Arp.scala 103:64]
    node _arpReqIn_valid_T_3 = and(_arpReqIn_valid_T_1, arpReqIn_valid_REG) @[Arp.scala 103:54]
    arpReqIn.valid <= _arpReqIn_valid_T_3 @[Arp.scala 103:18]
    inst arpReqOut of Queue_1 @[Decoupled.scala 296:21]
    arpReqOut.clock <= clock
    arpReqOut.reset <= reset
    arpReqOut.io.enq.valid <= arpReqIn.valid @[Decoupled.scala 297:22]
    arpReqOut.io.enq.bits <= arpReqIn.bits @[Decoupled.scala 298:21]
    arpReqIn.ready <= arpReqOut.io.enq.ready @[Decoupled.scala 299:17]
    wire ipReqIn : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>} @[Arp.scala 106:21]
    node ipReqIn_bits_hi = cat(UInt<1>("h00"), io.ip2Arp.sendReq.bits) @[Cat.scala 30:58]
    node _ipReqIn_bits_T = cat(ipReqIn_bits_hi, UInt<48>("h0ffffffffffff")) @[Cat.scala 30:58]
    ipReqIn.bits <= _ipReqIn_bits_T @[Arp.scala 107:16]
    ipReqIn.valid <= io.ip2Arp.sendReq.valid @[Arp.scala 108:17]
    inst ipReqOut of Queue_2 @[Decoupled.scala 296:21]
    ipReqOut.clock <= clock
    ipReqOut.reset <= reset
    ipReqOut.io.enq.valid <= ipReqIn.valid @[Decoupled.scala 297:22]
    ipReqOut.io.enq.bits <= ipReqIn.bits @[Decoupled.scala 298:21]
    ipReqIn.ready <= ipReqOut.io.enq.ready @[Decoupled.scala 299:17]
    wire arpSend : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<81>} @[Arp.scala 111:21]
    inst arb of Arbiter @[Arp.scala 112:19]
    arb.clock <= clock
    arb.reset <= reset
    arb.io.in[0].bits <= ipReqOut.io.deq.bits @[Arp.scala 113:16]
    arb.io.in[0].valid <= ipReqOut.io.deq.valid @[Arp.scala 113:16]
    ipReqOut.io.deq.ready <= arb.io.in[0].ready @[Arp.scala 113:16]
    arb.io.in[1].bits <= arpReqOut.io.deq.bits @[Arp.scala 114:16]
    arb.io.in[1].valid <= arpReqOut.io.deq.valid @[Arp.scala 114:16]
    arpReqOut.io.deq.ready <= arb.io.in[1].ready @[Arp.scala 114:16]
    arpSend.bits <= arb.io.out.bits @[Arp.scala 115:11]
    arpSend.valid <= arb.io.out.valid @[Arp.scala 115:11]
    arb.io.out.ready <= arpSend.ready @[Arp.scala 115:11]
    arpSend.ready <= UInt<1>("h00") @[Arp.scala 116:17]
    reg sState : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Arp.scala 119:29]
    reg value_1 : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Counter.scala 60:40]
    node _arpSendReg_T = and(arpSend.ready, arpSend.valid) @[Decoupled.scala 40:37]
    reg arpSendReg : UInt<81>, clock @[Reg.scala 15:16]
    when _arpSendReg_T : @[Reg.scala 16:19]
      arpSendReg <= arpSend.bits @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire arpSendOp : UInt<1> @[Arp.scala 125:23]
    wire arpSendIp : UInt<32> @[Arp.scala 126:23]
    wire arpSendMac : UInt<48> @[Arp.scala 127:24]
    node _arpSendOp_T = bits(arpSendReg, 80, 80) @[Arp.scala 128:26]
    arpSendOp <= _arpSendOp_T @[Arp.scala 128:13]
    node _arpSendIp_T = bits(arpSendReg, 79, 48) @[Arp.scala 129:26]
    arpSendIp <= _arpSendIp_T @[Arp.scala 129:13]
    node _arpSendMac_T = bits(arpSendReg, 47, 0) @[Arp.scala 130:27]
    arpSendMac <= _arpSendMac_T @[Arp.scala 130:14]
    node _T_58 = eq(UInt<4>("h00"), sState) @[Conditional.scala 37:30]
    when _T_58 : @[Conditional.scala 40:58]
      node _T_59 = and(io.arp2Mac.ready, arpSend.valid) @[Arp.scala 134:30]
      when _T_59 : @[Arp.scala 134:48]
        arpSend.ready <= UInt<1>("h01") @[Arp.scala 135:23]
        sState <= UInt<4>("h01") @[Arp.scala 136:22]
        skip @[Arp.scala 134:48]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_60 = eq(UInt<4>("h01"), sState) @[Conditional.scala 37:30]
      when _T_60 : @[Conditional.scala 39:67]
        wire v : UInt<8>[6] @[package.scala 150:17]
        v[0] <= UInt<8>("h00") @[package.scala 152:12]
        v[1] <= UInt<8>("h01") @[package.scala 152:12]
        v[2] <= UInt<8>("h08") @[package.scala 152:12]
        v[3] <= UInt<8>("h00") @[package.scala 152:12]
        v[4] <= UInt<8>("h06") @[package.scala 152:12]
        v[5] <= UInt<8>("h04") @[package.scala 152:12]
        io.arp2Mac.bits <= v[value_1] @[package.scala 74:18]
        node wrap_6 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
        node _value_T_12 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
        node _value_T_13 = tail(_value_T_12, 1) @[Counter.scala 76:24]
        value_1 <= _value_T_13 @[Counter.scala 76:15]
        node _T_61 = eq(value_1, UInt<3>("h05")) @[package.scala 76:24]
        when _T_61 : @[package.scala 76:46]
          value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
          sState <= UInt<4>("h02") @[package.scala 78:16]
          skip @[package.scala 76:46]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_62 = eq(UInt<4>("h02"), sState) @[Conditional.scala 37:30]
        when _T_62 : @[Conditional.scala 39:67]
          when arpSendOp : @[Arp.scala 143:24]
            wire v_1 : UInt<8>[2] @[package.scala 150:17]
            v_1[0] <= UInt<8>("h00") @[package.scala 152:12]
            v_1[1] <= UInt<8>("h02") @[package.scala 152:12]
            node _io_arp2Mac_bits_T = bits(value_1, 0, 0)
            io.arp2Mac.bits <= v_1[_io_arp2Mac_bits_T] @[package.scala 74:18]
            node wrap_7 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
            node _value_T_14 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
            node _value_T_15 = tail(_value_T_14, 1) @[Counter.scala 76:24]
            value_1 <= _value_T_15 @[Counter.scala 76:15]
            node _T_63 = eq(value_1, UInt<1>("h01")) @[package.scala 76:24]
            when _T_63 : @[package.scala 76:46]
              value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
              sState <= UInt<4>("h03") @[package.scala 78:16]
              skip @[package.scala 76:46]
            skip @[Arp.scala 143:24]
          else : @[Arp.scala 145:9]
            wire v_2 : UInt<8>[2] @[package.scala 150:17]
            v_2[0] <= UInt<8>("h00") @[package.scala 152:12]
            v_2[1] <= UInt<8>("h01") @[package.scala 152:12]
            node _io_arp2Mac_bits_T_1 = bits(value_1, 0, 0)
            io.arp2Mac.bits <= v_2[_io_arp2Mac_bits_T_1] @[package.scala 74:18]
            node wrap_8 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
            node _value_T_16 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
            node _value_T_17 = tail(_value_T_16, 1) @[Counter.scala 76:24]
            value_1 <= _value_T_17 @[Counter.scala 76:15]
            node _T_64 = eq(value_1, UInt<1>("h01")) @[package.scala 76:24]
            when _T_64 : @[package.scala 76:46]
              value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
              sState <= UInt<4>("h03") @[package.scala 78:16]
              skip @[package.scala 76:46]
            skip @[Arp.scala 145:9]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_65 = eq(UInt<4>("h03"), sState) @[Conditional.scala 37:30]
          when _T_65 : @[Conditional.scala 39:67]
            wire _WIRE : UInt<8>[6] @[package.scala 158:31]
            _WIRE[0] <= UInt<8>("h012") @[package.scala 158:31]
            _WIRE[1] <= UInt<8>("h034") @[package.scala 158:31]
            _WIRE[2] <= UInt<8>("h055") @[package.scala 158:31]
            _WIRE[3] <= UInt<8>("h0aa") @[package.scala 158:31]
            _WIRE[4] <= UInt<8>("h0ff") @[package.scala 158:31]
            _WIRE[5] <= UInt<8>("h00") @[package.scala 158:31]
            io.arp2Mac.bits <= _WIRE[value_1] @[package.scala 74:18]
            node wrap_9 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
            node _value_T_18 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
            node _value_T_19 = tail(_value_T_18, 1) @[Counter.scala 76:24]
            value_1 <= _value_T_19 @[Counter.scala 76:15]
            node _T_66 = eq(value_1, UInt<3>("h05")) @[package.scala 76:24]
            when _T_66 : @[package.scala 76:46]
              value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
              sState <= UInt<4>("h04") @[package.scala 78:16]
              skip @[package.scala 76:46]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_67 = eq(UInt<4>("h04"), sState) @[Conditional.scala 37:30]
            when _T_67 : @[Conditional.scala 39:67]
              wire _WIRE_1 : UInt<8>[4] @[package.scala 158:31]
              _WIRE_1[0] <= UInt<8>("h0aa") @[package.scala 158:31]
              _WIRE_1[1] <= UInt<8>("h0bb") @[package.scala 158:31]
              _WIRE_1[2] <= UInt<8>("h0cc") @[package.scala 158:31]
              _WIRE_1[3] <= UInt<8>("h0dd") @[package.scala 158:31]
              node _io_arp2Mac_bits_T_2 = bits(value_1, 1, 0)
              io.arp2Mac.bits <= _WIRE_1[_io_arp2Mac_bits_T_2] @[package.scala 74:18]
              node wrap_10 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
              node _value_T_20 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
              node _value_T_21 = tail(_value_T_20, 1) @[Counter.scala 76:24]
              value_1 <= _value_T_21 @[Counter.scala 76:15]
              node _T_68 = eq(value_1, UInt<2>("h03")) @[package.scala 76:24]
              when _T_68 : @[package.scala 76:46]
                value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
                sState <= UInt<4>("h05") @[package.scala 78:16]
                skip @[package.scala 76:46]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_69 = eq(UInt<4>("h05"), sState) @[Conditional.scala 37:30]
              when _T_69 : @[Conditional.scala 39:67]
                wire v_3 : UInt<8>[6] @[package.scala 150:17]
                node _v_0_T = bits(arpSendMac, 47, 40) @[package.scala 152:16]
                v_3[0] <= _v_0_T @[package.scala 152:12]
                node _v_1_T = bits(arpSendMac, 39, 32) @[package.scala 152:16]
                v_3[1] <= _v_1_T @[package.scala 152:12]
                node _v_2_T = bits(arpSendMac, 31, 24) @[package.scala 152:16]
                v_3[2] <= _v_2_T @[package.scala 152:12]
                node _v_3_T = bits(arpSendMac, 23, 16) @[package.scala 152:16]
                v_3[3] <= _v_3_T @[package.scala 152:12]
                node _v_4_T = bits(arpSendMac, 15, 8) @[package.scala 152:16]
                v_3[4] <= _v_4_T @[package.scala 152:12]
                node _v_5_T = bits(arpSendMac, 7, 0) @[package.scala 152:16]
                v_3[5] <= _v_5_T @[package.scala 152:12]
                io.arp2Mac.bits <= v_3[value_1] @[package.scala 74:18]
                node wrap_11 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
                node _value_T_22 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
                node _value_T_23 = tail(_value_T_22, 1) @[Counter.scala 76:24]
                value_1 <= _value_T_23 @[Counter.scala 76:15]
                node _T_70 = eq(value_1, UInt<3>("h05")) @[package.scala 76:24]
                when _T_70 : @[package.scala 76:46]
                  value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
                  sState <= UInt<4>("h06") @[package.scala 78:16]
                  skip @[package.scala 76:46]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_71 = eq(UInt<4>("h06"), sState) @[Conditional.scala 37:30]
                when _T_71 : @[Conditional.scala 39:67]
                  wire v_4 : UInt<8>[4] @[package.scala 150:17]
                  node _v_0_T_1 = bits(arpSendIp, 31, 24) @[package.scala 152:16]
                  v_4[0] <= _v_0_T_1 @[package.scala 152:12]
                  node _v_1_T_1 = bits(arpSendIp, 23, 16) @[package.scala 152:16]
                  v_4[1] <= _v_1_T_1 @[package.scala 152:12]
                  node _v_2_T_1 = bits(arpSendIp, 15, 8) @[package.scala 152:16]
                  v_4[2] <= _v_2_T_1 @[package.scala 152:12]
                  node _v_3_T_1 = bits(arpSendIp, 7, 0) @[package.scala 152:16]
                  v_4[3] <= _v_3_T_1 @[package.scala 152:12]
                  node _io_arp2Mac_bits_T_3 = bits(value_1, 1, 0)
                  io.arp2Mac.bits <= v_4[_io_arp2Mac_bits_T_3] @[package.scala 74:18]
                  node wrap_12 = eq(value_1, UInt<3>("h07")) @[Counter.scala 72:24]
                  node _value_T_24 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
                  node _value_T_25 = tail(_value_T_24, 1) @[Counter.scala 76:24]
                  value_1 <= _value_T_25 @[Counter.scala 76:15]
                  node _T_72 = eq(value_1, UInt<2>("h03")) @[package.scala 76:24]
                  when _T_72 : @[package.scala 76:46]
                    value_1 <= UInt<1>("h00") @[Counter.scala 97:11]
                    sState <= UInt<4>("h00") @[package.scala 78:16]
                    skip @[package.scala 76:46]
                  skip @[Conditional.scala 39:67]
    node _arpSend_ready_T = eq(sState, UInt<4>("h00")) @[Arp.scala 163:33]
    arpSend.ready <= _arpSend_ready_T @[Arp.scala 163:17]
    node _io_arp2Mac_valid_T = neq(sState, UInt<4>("h00")) @[Arp.scala 164:36]
    io.arp2Mac.valid <= _io_arp2Mac_valid_T @[Arp.scala 164:20]
    wire _io_debugPort_op_WIRE : UInt @[Arp.scala 166:33]
    node _io_debugPort_op_T = cat(op[1], op[0]) @[Arp.scala 166:33]
    _io_debugPort_op_WIRE <= _io_debugPort_op_T @[Arp.scala 166:33]
    io.debugPort.op <= _io_debugPort_op_WIRE @[Arp.scala 166:19]
    wire _io_debugPort_macSrc_WIRE : UInt @[Arp.scala 167:41]
    node io_debugPort_macSrc_lo_hi = cat(macSrc[2], macSrc[1]) @[Arp.scala 167:41]
    node io_debugPort_macSrc_lo = cat(io_debugPort_macSrc_lo_hi, macSrc[0]) @[Arp.scala 167:41]
    node io_debugPort_macSrc_hi_hi = cat(macSrc[5], macSrc[4]) @[Arp.scala 167:41]
    node io_debugPort_macSrc_hi = cat(io_debugPort_macSrc_hi_hi, macSrc[3]) @[Arp.scala 167:41]
    node _io_debugPort_macSrc_T = cat(io_debugPort_macSrc_hi, io_debugPort_macSrc_lo) @[Arp.scala 167:41]
    _io_debugPort_macSrc_WIRE <= _io_debugPort_macSrc_T @[Arp.scala 167:41]
    io.debugPort.macSrc <= _io_debugPort_macSrc_WIRE @[Arp.scala 167:23]
    wire _io_debugPort_macDest_WIRE : UInt @[Arp.scala 168:43]
    node io_debugPort_macDest_lo_hi = cat(macDest[2], macDest[1]) @[Arp.scala 168:43]
    node io_debugPort_macDest_lo = cat(io_debugPort_macDest_lo_hi, macDest[0]) @[Arp.scala 168:43]
    node io_debugPort_macDest_hi_hi = cat(macDest[5], macDest[4]) @[Arp.scala 168:43]
    node io_debugPort_macDest_hi = cat(io_debugPort_macDest_hi_hi, macDest[3]) @[Arp.scala 168:43]
    node _io_debugPort_macDest_T = cat(io_debugPort_macDest_hi, io_debugPort_macDest_lo) @[Arp.scala 168:43]
    _io_debugPort_macDest_WIRE <= _io_debugPort_macDest_T @[Arp.scala 168:43]
    io.debugPort.macDest <= _io_debugPort_macDest_WIRE @[Arp.scala 168:24]
    wire _io_debugPort_ipSrc_WIRE : UInt @[Arp.scala 169:39]
    node io_debugPort_ipSrc_lo = cat(ipSrc[1], ipSrc[0]) @[Arp.scala 169:39]
    node io_debugPort_ipSrc_hi = cat(ipSrc[3], ipSrc[2]) @[Arp.scala 169:39]
    node _io_debugPort_ipSrc_T = cat(io_debugPort_ipSrc_hi, io_debugPort_ipSrc_lo) @[Arp.scala 169:39]
    _io_debugPort_ipSrc_WIRE <= _io_debugPort_ipSrc_T @[Arp.scala 169:39]
    io.debugPort.ipSrc <= _io_debugPort_ipSrc_WIRE @[Arp.scala 169:22]
    wire _io_debugPort_ipDest_WIRE : UInt @[Arp.scala 170:41]
    node io_debugPort_ipDest_lo = cat(ipDest[1], ipDest[0]) @[Arp.scala 170:41]
    node io_debugPort_ipDest_hi = cat(ipDest[3], ipDest[2]) @[Arp.scala 170:41]
    node _io_debugPort_ipDest_T = cat(io_debugPort_ipDest_hi, io_debugPort_ipDest_lo) @[Arp.scala 170:41]
    _io_debugPort_ipDest_WIRE <= _io_debugPort_ipDest_T @[Arp.scala 170:41]
    io.debugPort.ipDest <= _io_debugPort_ipDest_WIRE @[Arp.scala 170:23]
    io.debugPort.ramWriteEnable <= arpRamWriteEnable @[Arp.scala 171:31]
    io.debugPort.ramWriteAddr <= arpRamWriteAddress @[Arp.scala 172:29]
    io.debugPort.ramWriteIp <= arpRamWriteData.ip @[Arp.scala 173:27]
    io.debugPort.ramWriteMac <= arpRamWriteData.mac @[Arp.scala 174:28]
    io.debugPort.arpOutValid <= io.arp2Mac.valid @[Arp.scala 175:28]
    io.debugPort.arpOutData <= io.arp2Mac.bits @[Arp.scala 176:27]
    
  module NetStack : 
    input clock : Clock
    input reset_n : UInt<1>
    output rgmii : {txClock : UInt<1>, txData : UInt<4>, txCtrl : UInt<1>, flip rxClock : UInt<1>, flip rxData : UInt<4>, flip rxCtrl : UInt<1>, ereset : UInt<1>}
    output led : UInt<4>
    
    node reset = eq(reset_n, UInt<1>("h00")) @[package.scala 13:17]
    inst pll of FpgaPll @[NetStack.scala 12:19]
    pll.locked is invalid
    pll.clk_250 is invalid
    pll.clk_200 is invalid
    pll.clk_125 is invalid
    pll.clk_100 is invalid
    pll.reset is invalid
    pll.clk_in is invalid
    pll.clk_in <= clock @[NetStack.scala 13:17]
    pll.reset <= reset @[NetStack.scala 14:16]
    rgmii.ereset is invalid @[NetStack.scala 16:9]
    rgmii.rxCtrl is invalid @[NetStack.scala 16:9]
    rgmii.rxData is invalid @[NetStack.scala 16:9]
    rgmii.rxClock is invalid @[NetStack.scala 16:9]
    rgmii.txCtrl is invalid @[NetStack.scala 16:9]
    rgmii.txData is invalid @[NetStack.scala 16:9]
    rgmii.txClock is invalid @[NetStack.scala 16:9]
    node _T = asAsyncReset(reset) @[NetStack.scala 18:55]
    inst rgmiiTransfer of RgmiiTransfer @[NetStack.scala 19:31]
    rgmiiTransfer.clock <= pll.clk_125
    rgmiiTransfer.reset <= _T
    inst macReceive of MacReceive @[NetStack.scala 20:28]
    macReceive.clock <= pll.clk_125
    macReceive.reset <= _T
    inst arp of Arp @[NetStack.scala 21:21]
    arp.clock <= pll.clk_125
    arp.reset <= _T
    rgmiiTransfer.io.debugPort.fallFifo is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.debugPort.riseFifo is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.debugPort.rxData is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.debugPort.rxValid is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.debugPort.rgmiiRxData is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.debugPort.rgmiiRxCtrl is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.debugPort.rgmiiRxClock is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.tx.bits is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.tx.valid is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rx.bits is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rx.valid is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.ereset is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.rxCtrl is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.rxData is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.rxClock is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.txCtrl is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.txData is invalid @[NetStack.scala 23:22]
    rgmiiTransfer.io.rgmii.txClock is invalid @[NetStack.scala 23:22]
    macReceive.io.debugPort.fifoOutEnd is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.fifoOutStart is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.fifoOutFire is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.fifoInEnd is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.fifoInStart is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.fifoInValid is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.ipTxData is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.ipTxValid is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.arpTxData is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.arpTxValid is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macReadData is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macReadAddress is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macReadEnable is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macWriteData is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macWriteAddress is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macWriteEnable is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.macType is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.cnt is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.state is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.rxData is invalid @[NetStack.scala 24:19]
    macReceive.io.debugPort.rxValid is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2CrcIf.crcErr is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2CrcIf.crcDone is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2CrcIf.crcData.bits is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2CrcIf.crcData.valid is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2IpIf.ipData.bits is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2IpIf.ipData.valid is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2IpIf.arpData.bits is invalid @[NetStack.scala 24:19]
    macReceive.io.mac2IpIf.arpData.valid is invalid @[NetStack.scala 24:19]
    macReceive.io.rx.bits is invalid @[NetStack.scala 24:19]
    macReceive.io.rx.valid is invalid @[NetStack.scala 24:19]
    arp.io.debugPort.arpOutData is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.arpOutValid is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.ramWriteMac is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.ramWriteIp is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.ramWriteAddr is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.ramWriteEnable is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.ipDest is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.macDest is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.ipSrc is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.macSrc is invalid @[NetStack.scala 25:12]
    arp.io.debugPort.op is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.sendReq.bits is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.sendReq.valid is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.sendReq.ready is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.queryResp.bits is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.queryResp.valid is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.queryReq.bits is invalid @[NetStack.scala 25:12]
    arp.io.ip2Arp.queryReq.valid is invalid @[NetStack.scala 25:12]
    arp.io.arp2Mac.bits is invalid @[NetStack.scala 25:12]
    arp.io.arp2Mac.valid is invalid @[NetStack.scala 25:12]
    arp.io.arp2Mac.ready is invalid @[NetStack.scala 25:12]
    arp.io.mac2Arp.bits is invalid @[NetStack.scala 25:12]
    arp.io.mac2Arp.valid is invalid @[NetStack.scala 25:12]
    rgmii.ereset <= rgmiiTransfer.io.rgmii.ereset @[NetStack.scala 27:28]
    rgmiiTransfer.io.rgmii.rxCtrl <= rgmii.rxCtrl @[NetStack.scala 27:28]
    rgmiiTransfer.io.rgmii.rxData <= rgmii.rxData @[NetStack.scala 27:28]
    rgmiiTransfer.io.rgmii.rxClock <= rgmii.rxClock @[NetStack.scala 27:28]
    rgmii.txCtrl <= rgmiiTransfer.io.rgmii.txCtrl @[NetStack.scala 27:28]
    rgmii.txData <= rgmiiTransfer.io.rgmii.txData @[NetStack.scala 27:28]
    rgmii.txClock <= rgmiiTransfer.io.rgmii.txClock @[NetStack.scala 27:28]
    macReceive.io.rx.bits <= rgmiiTransfer.io.rx.bits @[NetStack.scala 28:25]
    macReceive.io.rx.valid <= rgmiiTransfer.io.rx.valid @[NetStack.scala 28:25]
    arp.io.mac2Arp.bits <= macReceive.io.mac2IpIf.arpData.bits @[NetStack.scala 29:36]
    arp.io.mac2Arp.valid <= macReceive.io.mac2IpIf.arpData.valid @[NetStack.scala 29:36]
    arp.io.arp2Mac.ready <= UInt<1>("h01") @[NetStack.scala 34:26]
    rgmii.ereset <= reset_n @[NetStack.scala 38:16]
    node _T_1 = asAsyncReset(reset) @[NetStack.scala 39:55]
    reg led_lo : UInt<1>, pll.clk_100 with : (reset => (_T_1, UInt<1>("h00"))) @[NetStack.scala 40:25]
    reg done_value : UInt<26>, pll.clk_100 with : (reset => (_T_1, UInt<26>("h00"))) @[Counter.scala 60:40]
    wire done : UInt<1>
    done <= UInt<1>("h00")
    when UInt<1>("h01") : @[Counter.scala 118:17]
      node done_wrap_wrap = eq(done_value, UInt<26>("h02faf07f")) @[Counter.scala 72:24]
      node _done_wrap_value_T = add(done_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _done_wrap_value_T_1 = tail(_done_wrap_value_T, 1) @[Counter.scala 76:24]
      done_value <= _done_wrap_value_T_1 @[Counter.scala 76:15]
      when done_wrap_wrap : @[Counter.scala 86:20]
        done_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      done <= done_wrap_wrap @[Counter.scala 118:24]
      skip @[Counter.scala 118:17]
    when done : @[NetStack.scala 42:17]
      node _ledReg_T = eq(led_lo, UInt<1>("h00")) @[NetStack.scala 42:29]
      led_lo <= _ledReg_T @[NetStack.scala 42:26]
      skip @[NetStack.scala 42:17]
    node _led_T = cat(UInt<1>("h00"), led_lo) @[Cat.scala 30:58]
    led <= _led_T @[NetStack.scala 43:9]
    
